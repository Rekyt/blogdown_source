?if
()
?ifelse
k <- apply(data, 1, function(ligne) {
if (ligne[["sex"]] == "F") {
ageclass <- character()
if (ligne[["age"]] >= 1 & ligne[["age"]] < 3) {
ageclass <- "juvenile"
} else if(ligne[["age"]] >= 3 & ligne[["age"]] < 4) {
ageclass <- "ado"
} else if(ligne[["age"]] >= 4){
ageclass <- "adulte"
}
}
if (ligne[["sex"]] == "M"){
if (ligne[["age"]] >= 1 & ligne[["age"]] < 3){
ageclass <- "juvenile"
} else if(ligne[["age"]] >= 3 & ligne[["age"]] < 7){
ageclass <- "ado"
} else if(ligne[["age"]] >= 7){
ageclass <- "adulte"
}
}
return(ageclass)
})
head(k)
k[7:10]
k[10]
as.character(k)
data[10,]
data[10,"age"] >= 7
k <- apply(data, 1, function(ligne) {
if (ligne[["sex"]] == "F") {
if (ligne[["age"]] >= 1 & ligne[["age"]] < 3) {
ageclass <- "juvenile"
} else if(ligne[["age"]] >= 3 & ligne[["age"]] < 4) {
ageclass <- "ado"
} else if(ligne[["age"]] >= 4){
ageclass <- "adulte"
}
}
if (ligne[["sex"]] == "M"){
if (ligne[["age"]] >= 1 & ligne[["age"]] < 3){
ageclass <- "juvenile"
} else if(ligne[["age"]] >= 3 & ligne[["age"]] < 7){
ageclass <- "ado"
} else if(ligne[["age"]] >= 7){
ageclass <- "adulte"
}
}
return(ageclass)
})
as.character(k)
head(data)
apply(data, 1, function(ligne) {
if(ligne["age"] > 7) {
print("pouet")
}
})
l = apply(data, 1, function(ligne) {
if(ligne["age"] > 7) {
return("pouet")
}
})
head(l)
l
ma_function(x) { if(x[["age"]] > 7) {return("pouet")}}
ma = function(x) { if(x[["age"]] > 7) {return("pouet")}}
ma(c(age = 3))
ma(c(age = 8))
apply(data, 1, ma)
n = function(x) return(str(x))
apply(data, 1, n)
x
apply(data, 1, typeof)
n = function(x) return(str(x[["age"]]))
apply(data, 1, n)
n = function(x) return(typeof(x[["age"]]))
apply(data, 1, n)
n = function(x) return(typeof(x["age"]))
apply(data, 1, n)
head(data)
crabs
l = apply(data, 1, function(ligne) {
if(ligne[["age"]] > 7) {
return("pouet")
}
})
l
l = apply(data, 1, function(ligne) {
if(as.numeric(ligne[["age"]]) > 7) {
return("pouet")
}
})
l
k <- apply(data, 1, function(ligne) {
sex = ligne[["sex"]]
# /!\ On doit transformer cette valeur en 'numeric' sinon pose problème
#     dans les comparaisons suivantes
age = as.numeric(ligne[["sex"]])
if (sex == "F") {
if (age >= 1 & age < 3) {
ageclass <- "juvenile"
} else if(age >= 3 & age < 4) {
ageclass <- "ado"
} else if(age >= 4){
ageclass <- "adulte"
}
}
if (ligne[["sex"]] == "M"){
if (age >= 1 & age < 3){
ageclass <- "juvenile"
} else if(age >= 3 & age < 7){
ageclass <- "ado"
} else if(age >= 7){
ageclass <- "adulte"
}
}
return(ageclass)
})
ma_fun = function(ligne) {
sex = ligne[["sex"]]
# /!\ On doit transformer cette valeur en 'numeric' sinon pose problème
#     dans les comparaisons suivantes
age = as.numeric(ligne[["sex"]])
if (sex == "F") {
if (age >= 1 & age < 3) {
ageclass <- "juvenile"
} else if(age >= 3 & age < 4) {
ageclass <- "ado"
} else if(age >= 4){
ageclass <- "adulte"
}
}
if (ligne[["sex"]] == "M"){
if (age >= 1 & age < 3){
ageclass <- "juvenile"
} else if(age >= 3 & age < 7){
ageclass <- "ado"
} else if(age >= 7){
ageclass <- "adulte"
}
}
return(ageclass)
}
debugonce(ma_fun)
apply(data, 1, ma_fun)
ligne
sex
age
k <- apply(data, 1, function(ligne) {
sex = ligne[["sex"]]
# /!\ On doit transformer cette valeur en 'numeric' sinon pose problème
#     dans les comparaisons suivantes
age = as.numeric(ligne[["age"]])
if (sex == "F") {
if (age >= 1 & age < 3) {
ageclass <- "juvenile"
} else if(age >= 3 & age < 4) {
ageclass <- "ado"
} else if(age >= 4){
ageclass <- "adulte"
}
}
if (ligne[["sex"]] == "M"){
if (age >= 1 & age < 3){
ageclass <- "juvenile"
} else if(age >= 3 & age < 7){
ageclass <- "ado"
} else if(age >= 7){
ageclass <- "adulte"
}
}
return(ageclass)
})
head(k)
as.character(k)
# Intro boucles R: Exemples Avec Jeu de données
# Alice Percher
# On fixe la graine aléatoire pour obtenir systématiquement les mêmes résultats
# quand on fait tourner le script
set.seed(1)
# Chargement des données -------------------------------------------------------
# jeux de données = data, contenu dans le package MASS
library(MASS)
data <- crabs
View(data) # variables = espèce, sexe, index, et 5 variables quantitatives
# I: Transformation sexe -------------------------------------------------------
# I) on applique une valeur 1 chaque spécimen suivant 1 condition
# si le crabe est une femelle => 'lady', si mâle => 'gentleman'
v<-NULL # création du vecteur qui contient les valeurs (vide)
for (i in 1:nrow(data)){
if (data[i,]$sex == "F"){
v[i] <- "lady"
} else {
v[i] <- "gentleman"
}
}
# data[x,y] = matrice. i correspond à n'importe quelle ligne
# on a rempli le vecteur vide
# On ajoute le nouveau vecteur créé à notre tableau dans la colonne 'Lady or
# Gentleman' (LoG)
data$LoG = v
# On peut aussi plus simplement écrire :
data_copy <- crabs
data_copy[data_copy$sex == "M", "LoG"] <- "gentleman"
data_copy[data_copy$sex == "F", "LoG"] <- "lady"
# Ou même en une seule ligne (en utilisant la fonction 'ifelse()')
data_copy2 <- crabs
data_copy2[, "LoG"] <- ifelse(data_copy$sex == "M", "gentleman", "lady")
# II: Classe d'âge à deux conditions -------------------------------------------
# Vecteur âge aléatoire d'une longueur de 200 (nbre de lignes dans data)
age <- sample(1:20,200,replace = T)
# age compris entre 1 et 20 ans (oui les crabes vivent très vieux)
# 200 valeurs
# replace = T : on permet les remises (2 crabes peuvent avoir le même âge)
data <- cbind(data,age) # on ajoute le vecteur à la matrice, en tant que colonne
# on crée un vecteur classe d'âge
ageclass <- vector(length = 200)  # nbre de lignes dans data (équivaut à 'nrow(data)')
for (i in 1:nrow(data)){  # pour chaque individu #
if (data[i,]$sex == "F"){		# si c'est une femelle #
if (data[i,]$age >= 1 & data[i,]$age < 3){
# si l'âge de cet individu est sup ou égal à 1 et qu'il est inf à 3 alors on met juvénile dans la place correspondante du vecteur ageclass #
ageclass[i] <- "juvenile"
} else if (data[i,]$age >= 3 & data[i,]$age < 4){
ageclass[i] <- "ado"
} else if (data[i,]$age >= 4){
ageclass[i]<-"adulte"
}
}
if (data[i,]$sex == "M"){
if (data[i,]$age >= 1 & data[i,]$age < 3){
ageclass[i] <- "juvenile"
} else if (data[i,]$age >= 3 & data[i,]$age < 7){
ageclass[i] <- "ado"
} else if (data[i,]$age >= 7){
ageclass[i] <- "adulte"
}
}
}
data <- cbind(data,ageclass)
# La même chose avec 'apply()' sur les lignes
apply_ageclass <- apply(data, 1, function(ligne) {
sex = ligne[["sex"]]
# /!\ On doit transformer cette valeur en 'numeric' sinon pose problème
#     dans les comparaisons suivantes
age = as.numeric(ligne[["age"]])
if (sex == "F") {
if (age >= 1 & age < 3) {
ageclass <- "juvenile"
} else if(age >= 3 & age < 4) {
ageclass <- "ado"
} else if(age >= 4){
ageclass <- "adulte"
}
}
if (ligne[["sex"]] == "M"){
if (age >= 1 & age < 3){
ageclass <- "juvenile"
} else if(age >= 3 & age < 7){
ageclass <- "ado"
} else if(age >= 7){
ageclass <- "adulte"
}
}
return(ageclass)
})
data <- cbind(data, as.character(apply_ageclass))
head(data)
data <- cbind(data, apply_ageclass)
head(data)
ls')'
ls(à)
ls()
dist <- matrix(0,nc=200,nr=200)
for (i in 1:nrow(data)){
for (j in 1:nrow(data)){
dist[i,j] <- as.matrix(sqrt(((morf[i,2]-morf[j,2])^2)+((morf[i,3]-morf[j,3])^2)+((morf[i,4]-morf[j,4])^2)+((morf[i,5]-morf[j,5])^2)))
}
}
row.names(dist)<-data$index
colnames(dist)<-data$index
head(data)
morf <- data[, c("index", "FL", "RW", "CL", "CW", "BD")]
for (i in 1:nrow(data)){
for (j in 1:nrow(data)){
dist[i,j] <- as.matrix(sqrt(((morf[i,2]-morf[j,2])^2)+((morf[i,3]-morf[j,3])^2)+((morf[i,4]-morf[j,4])^2)+((morf[i,5]-morf[j,5])^2)))
}
}
update.packages()
?readRDS
?setwd()
getwd()
?options
options(my_data_wd = "GJKJKJ")
getOption("my_data_wd")
options()
demo
demo()
demo(package = .packages(all.available = T))
demo("Xmas")
demo("Xmas", package = "animation")
library(animation)
demo("Xmas")
demo("community", package = "igraph")
library(igraph)
demo("community", package = "igraph")
?LearnBayes
??LearnBayes
help(LearnBayes)
help(package = "LearnBayes")
demo(topic = "plotrix", package = "plotrix")
library(plotrix)
demo(topic = "plotrix", package = "plotrix")
demo(topic = "plotrix", package = "SparseM")
demo(topic = "Visualization", package = "SparseM")
library(SparseM)
demo(topic = "Visualization", package = "SparseM")
X
ls()
str(X)
update.packages()
fr = ggplot2::map_data(region = "france")
fr = ggplot2::map_data("france")
ggplot2::fortify(fr)
summary(fr)
head(fr)
unique(fr$subregion)
# Create a map with ggplot2
# Packages ---------------------------------------------------------------------
library(ggplot2)
library(ggmap)
# Get France base map
france_map = map_data("france")
cities = c("Montpellier", "Rouen", "Poil")
lonlat = geocode(unique(cities))
lonlat
data.frame(cities, lonlat)
?coord_proj
?coord_map
# Create a map with ggplot2
# Packages
library(ggplot2)
library(ggmap)
# Get France base map (using 'ggplot2::map_data()' function)
france_map = map_data("france")
# Get cities longitude and latitude (using 'ggmap::geocode()' function)
cities = c("Montpellier", "Rouen", "Poil")
lonlat = geocode(unique(cities))
geo_cities = data.frame(cities, lonlat)
# Plot the map
ggplot(geo_cities, aes(lon, lat)) +
geom_map(data = france_map, map = france_map, fill = "gray85", colour = "gray65",
aes(x = long, y = lat, map_id = region))
coord_map() +
labs(x = "Longitude", y = "Latitude")
?labs
ggplot(geo_cities, aes(lon, lat)) +
geom_map(data = france_map, map = france_map, fill = "gray85", colour = "gray65",
aes(x = long, y = lat, map_id = region))
coord_map()
ggplot(geo_cities, aes(lon, lat)) +
geom_map(data = france_map, map = france_map, fill = "gray85", colour = "gray65",
aes(x = long, y = lat, map_id = region)) +
coord_map() +
labs(x = "Longitude", y = "Latitude")
ggplot(geo_cities, aes(lon, lat)) +
geom_map(data = france_map, map = france_map, fill = "gray85", colour = "gray65",
aes(x = long, y = lat, map_id = region)) +
coord_map() +
labs(x = "Longitude", y = "Latitude") +
geom_point(color = "darkblue")
gistr::gist_create(files =  "Projects/gists/map_ggplot2.R", public = TRUE, description = "Create map with ggplot2")
update.packages()
library(ggfortify)
fortify.RasterCommon
?fortify.RasterCommon
?fortify.RasterStack
?fortify.RasterBrick
?color
?colour
?scale_fill_brewer
vignette(package = "roxygen2")
vignette("rdkeywords", package = "roxygen2")
vignette("rd", package = "roxygen2")
update.packages()
install.packages("ppmlasso")
install.packages("spatstat")
library(lottery)
library(vegan)
data(BCI)
# Size (= number of trees) of subplots
comm.size <- rowSums(BCI)
# Minimum subplot sie
comm.size.min <- min(comm.size)
set.seed(101010)  # For reproducibility of results
# Rarefy to minimum sample size
bci.res <- rrarefy(BCI, sample = comm.size.min)
library(betapart)
# Compute diversity indices
rich.obs <- apply(bci.res, 1, function(x) sum(x != 0))
shan.obs <- apply(bci.res, 1, function(x) diversity(x, index = "shannon"))
beta.obs <- lapply(beta.pair.abund(bci.res), function(x) {
X = rowMeans(as.matrix(x), na.rm=T)
})$beta.bray
stats.obs <- c(rich.obs, shan.obs, beta.obs)
names(stats.obs) <- paste0(rep(c("rich", "shan", "beta"), each = 50), 1:50)
m.samp <- runif(2 * 10^5, min = 0, max = 1)
theta.samp <- runif(2 * 10^5, min = 0, max = 100)
library(parallel)
# Start up a parallel cluster
parallelCluster <- makeCluster(5)  #parallel::detectCores()) #Not using all of the cores
print(parallelCluster)
# Function to perform simulations
mkWorker <- function(m.samp, theta.samp, J)
{
require(lottery)
require(untb)
force(J)
force(m.samp)
force(theta.samp)
summCalc <- function(j, m.samp, theta.samp, J)
{
pool.samp <- lottery::coalesc(100*J, theta = theta.samp[j])$pool
meta.samp <- array(0, c(50, length(unique(pool.samp$sp))))
colnames(meta.samp) <- unique(pool.samp$sp)
for(i in 1:50)
{
comm.samp <- lottery::coalesc(J, m.samp[j], pool = pool.samp);
tab <- table(comm.samp$com[,2])
meta.samp[i,names(tab)] <- tab
}
rich.samp <- apply(meta.samp, 1, function(x) sum(x != 0))
shan.samp <- apply(meta.samp, 1, function(x) vegan::diversity(x, index = "shannon"))
beta.samp <- lapply(betapart::beta.pair.abund(meta.samp),
function(x) rowMeans(as.matrix(x), na.rm=T)
)$beta.bray
return(list(sum.stats = c(rich.samp, shan.samp, beta.samp),
param = c(m.samp[j], theta.samp[j])))
}
worker <- function(j) {
summCalc(j, m.samp, theta.samp,J)
}
return(worker)
}
m.samp
length(m.samp)
?parLapply
modelbci <- parLapply(parallelCluster, 1:10^2, mkWorker(m.samp, theta.samp, comm.size.min))
system.time((modelbci <- parLapply(parallelCluster, 1:10, mkWorker(m.samp, theta.samp, comm.size.min))))
str(modelbci)
lrngth(modelbci)
length(modelbci)
if(!is.null(parallelCluster)) {
stopCluster(parallelCluster)
parallelCluster <- c()
}
# Summary statistics and parameter values are extracted
# and stored in matrices
stats <- t(sapply(modelbci, function(x) x$sum.stats))
stats.sd <- apply(stats, 2, sd)
stats.mean <- apply(stats, 2, mean)
stats <- t(apply(stats, 1, function(x) (x - stats.mean)/stats.sd))
colnames(stats) <- paste0(rep(c("rich", "shan", "beta"), each = 50), 1:50)
stats.obs <- (stats.obs - stats.mean)/stats.sd
param <- t(sapply(modelbci, function(x) x$param))
colnames(param) <- c("m", "theta")
param
stats
str(stats)
head(param)
str(param)
install.packages(c("Amelia", "missMDA", "VIM"))
update.packages()
update.packages()
update.packages()
update.packages()
cor(mtcars)
?cor
cor.test(~mpg + cyl + wt, data = mtcars)
cor.test(~mpg + cyl, data = mtcars)
update.packages(ask = F)
psych::corr.test(mtcars)
library("ggplot2")
setwd("/Volumes/TOSHIBA/")
load("20141031.RData", verbose = TRUE)
ls()
head(texture.glm)
texture.glm
str(INFOSOL)
INFOSOL
setwd("~/")
setwd("/Volumes/TOSHIBA/")
setwd("~")
load("/Volumes/TOSHIBA/20141031.RData")
head(rel.envt)
dim(rel.envt)
saveRDS(rel.envt, "Documents/Thèse/projects/multitrophic/data/raw/DIVGRASS/divgrass_envt.Rds")
install.packages("dismo")
install.packages("SSDM")
update.packages(ask = FALSE)
install.packages("drake")
remotes::install_github("ropensci/drake", build_vignettes = TRUE)
setwd("Projects")
library("blogdown")
new_site("blogdown_source/", theme = "gcushen/hugo-academic", format = "toml")
serve_site()
serve_site()
serve_site("blogdown_source/")
setwd("blogdown_source")
serve_site()
build_site()
